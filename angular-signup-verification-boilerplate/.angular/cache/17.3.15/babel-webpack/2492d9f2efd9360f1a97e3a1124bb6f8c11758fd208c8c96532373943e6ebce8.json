{"ast":null,"code":"import { of, throwError } from 'rxjs';\nimport { map, catchError, delay, tap } from 'rxjs/operators';\nimport { environment } from '@environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nconst baseUrl = `${environment.apiUrl}/workflows`;\nexport let WorkflowService = /*#__PURE__*/(() => {\n  class WorkflowService {\n    constructor(http) {\n      this.http = http;\n      // Cache to persist workflow statuses between page navigations\n      this.workflowCache = new Map();\n    }\n    getByEmployeeId(employeeId) {\n      console.log(`Getting workflows for employee ${employeeId}`);\n      return this.http.get(`${baseUrl}/employee/${employeeId}`).pipe(tap(workflows => console.log(`Received ${workflows.length} workflows from API`)), map(workflows => {\n        // Apply any cached statuses to the workflows\n        return workflows.map(workflow => {\n          const cachedWorkflow = this.workflowCache.get(workflow.id?.toString());\n          if (cachedWorkflow) {\n            return {\n              ...workflow,\n              status: cachedWorkflow.status\n            };\n          }\n          return workflow;\n        });\n      }), catchError(error => {\n        console.error(`Error getting workflows for employee ${employeeId}:`, error);\n        // Return empty array on error instead of mock data\n        return of([]);\n      }));\n    }\n    // Helper method to format request details for workflow creation\n    formatRequestDetails(request) {\n      // Extract and format item information\n      const itemsText = request.requestItems ? request.requestItems.map(item => {\n        return `${item.name} (x${item.quantity})`;\n      }).join(', ') : '';\n      return {\n        requestId: request.id,\n        items: itemsText\n      };\n    }\n    // Helper method to create or update a workflow for the request\n    createRequestWorkflow(request) {\n      // Skip workflow creation if request is invalid\n      if (!request || !request.id) {\n        console.warn('Cannot create workflow for invalid request:', request);\n        return of(null);\n      }\n      // Get employeeId safely - handle both string and number formats\n      const employeeId = typeof request.employee?.id === 'string' ? parseInt(request.employee.id, 10) : request.employee?.id;\n      if (!employeeId) {\n        console.warn('Cannot create workflow without employeeId:', request);\n        return of(null);\n      }\n      // Prepare workflow details based on request type\n      const itemsText = request.requestItems ? request.requestItems.map(item => {\n        return `${item.name} (x${item.quantity})`;\n      }).join(', ') : '';\n      // Create workflow object with detailed information\n      const workflow = {\n        employeeId: employeeId,\n        // Now guaranteed to be a number\n        type: `${request.type} Request`,\n        details: {\n          items: itemsText,\n          requestId: request.id\n        },\n        status: 'Pending'\n      };\n      console.log('Creating workflow for request:', workflow);\n      return this.create(workflow);\n    }\n    create(workflow) {\n      console.log('Creating workflow:', workflow);\n      // Format details if this is a request type workflow\n      if (workflow.type && workflow.type.includes('Request') && workflow.details) {\n        // Ensure the request details are properly formatted\n        if (!workflow.details.items && workflow.details.requestItems) {\n          workflow.details = this.formatRequestDetails(workflow.details);\n        }\n      }\n      return this.http.post(baseUrl, workflow).pipe(tap(createdWorkflow => console.log('Created workflow:', createdWorkflow)), catchError(error => {\n        console.error('Error creating workflow:', error);\n        // Return a mock success response with the workflow data\n        return of({\n          ...workflow,\n          id: Math.floor(Math.random() * 1000)\n        });\n      }));\n    }\n    updateStatus(id, status) {\n      // Make sure id is always converted to string for consistency\n      const idStr = id.toString();\n      console.log(`Updating workflow ${idStr} status to ${status}`);\n      // Update the cache immediately for optimistic UI updates\n      const existingWorkflow = this.workflowCache.get(idStr);\n      if (existingWorkflow) {\n        // If the workflow already exists in cache, just update its status\n        existingWorkflow.status = status;\n        this.workflowCache.set(idStr, existingWorkflow);\n      } else {\n        // If it doesn't exist in cache, create a minimal valid Workflow object\n        const minimalWorkflow = {\n          id: Number(idStr),\n          employeeId: 0,\n          // Default value\n          type: 'Unknown',\n          // Default value\n          details: {},\n          // Default empty object\n          status: status\n        };\n        this.workflowCache.set(idStr, minimalWorkflow);\n      }\n      // Make the actual API call\n      return this.http.put(`${baseUrl}/${idStr}/status`, {\n        status\n      }).pipe(tap(updatedWorkflow => {\n        console.log('Workflow status updated successfully:', updatedWorkflow);\n        // Update cache with the response from the server\n        this.workflowCache.set(idStr, updatedWorkflow);\n      }), catchError(error => {\n        console.error(`Error updating workflow ${idStr} status:`, error);\n        return throwError(() => error);\n      }));\n    }\n    createOnboarding(params) {\n      console.log('Creating onboarding workflow:', params);\n      return this.http.post(`${baseUrl}/onboarding`, params).pipe(tap(workflow => console.log('Created onboarding workflow:', workflow)), catchError(error => {\n        console.error('Error creating onboarding workflow:', error);\n        return throwError(() => error);\n      }));\n    }\n    // Get all requests\n    getAllRequests() {\n      return this.http.get(`${baseUrl}/requests`).pipe(catchError(() => {\n        // Mock data if API fails or doesn't exist yet\n        return of([{\n          id: 1,\n          type: 'Equipment Request',\n          status: 'Pending',\n          dateSubmitted: new Date('2023-11-01'),\n          employee: {\n            id: '1',\n            employeeId: 'EMP001',\n            firstName: 'John',\n            lastName: 'Doe'\n          },\n          requestItems: [{\n            id: 1,\n            name: 'Laptop',\n            quantity: 1,\n            description: 'MacBook Pro 16\"'\n          }, {\n            id: 2,\n            name: 'Monitor',\n            quantity: 2,\n            description: '27\" 4K Display'\n          }]\n        }, {\n          id: 2,\n          type: 'Office Supplies',\n          status: 'Approved',\n          dateSubmitted: new Date('2023-10-25'),\n          dateUpdated: new Date('2023-10-26'),\n          employee: {\n            id: '2',\n            employeeId: 'EMP002',\n            firstName: 'Jane',\n            lastName: 'Smith'\n          },\n          requestItems: [{\n            id: 3,\n            name: 'Notebook',\n            quantity: 5\n          }, {\n            id: 4,\n            name: 'Pens',\n            quantity: 20\n          }],\n          approverName: 'Admin User',\n          approverId: 'admin-id'\n        }, {\n          id: 3,\n          type: 'Training Request',\n          status: 'Rejected',\n          dateSubmitted: new Date('2023-10-15'),\n          dateUpdated: new Date('2023-10-17'),\n          employee: {\n            id: '3',\n            employeeId: 'EMP003',\n            firstName: 'Mike',\n            lastName: 'Johnson'\n          },\n          requestItems: [{\n            id: 5,\n            name: 'Angular Course',\n            quantity: 1,\n            description: 'Advanced Angular Training'\n          }],\n          approverName: 'Admin User',\n          approverId: 'admin-id',\n          comments: 'Budget constraints, please resubmit next quarter'\n        }]).pipe(delay(1000)); // Add artificial delay to simulate network\n      }));\n    }\n    // Get requests for a specific user\n    getUserRequests(userId) {\n      return this.http.get(`${baseUrl}/requests/user/${userId}`).pipe(catchError(() => {\n        // Mock filtered data\n        return this.getAllRequests().pipe(map(requests => requests.filter(req => req.employee?.id === userId)));\n      }));\n    }\n    // Get a specific request by ID\n    getRequestById(id) {\n      return this.http.get(`${baseUrl}/requests/${id}`).pipe(catchError(() => {\n        // Mock data for a specific request\n        return this.getAllRequests().pipe(map(requests => requests.find(req => req.id === id)));\n      }));\n    }\n    // Create a new request\n    createRequest(request) {\n      return this.http.post(`${baseUrl}/requests`, request).pipe(catchError(() => {\n        // Mock creating a request\n        const newRequest = {\n          id: Math.floor(Math.random() * 1000) + 10,\n          status: 'Pending',\n          dateSubmitted: new Date(),\n          ...request\n        };\n        return of(newRequest).pipe(delay(500));\n      }));\n    }\n    // Update request status (approve/reject)\n    updateRequestStatus(id, status, comments) {\n      return this.http.put(`${baseUrl}/requests/${id}/status`, {\n        status,\n        comments\n      }).pipe(catchError(() => {\n        // Mock updating status\n        return this.getRequestById(id).pipe(map(request => {\n          return {\n            ...request,\n            status,\n            comments,\n            dateUpdated: new Date()\n          };\n        }), delay(500));\n      }));\n    }\n    // Delete a request\n    deleteRequest(id) {\n      return this.http.delete(`${baseUrl}/requests/${id}`).pipe(catchError(() => {\n        // Mock delete operation\n        return of(undefined).pipe(delay(500));\n      }));\n    }\n    // Update a request\n    updateRequest(id, request) {\n      return this.http.put(`${baseUrl}/requests/${id}`, request).pipe(catchError(() => {\n        // Mock update operation\n        const updatedRequest = {\n          ...request,\n          id,\n          dateUpdated: new Date()\n        };\n        return of(updatedRequest).pipe(delay(500));\n      }));\n    }\n    getAll() {\n      return this.http.get(baseUrl).pipe(catchError(error => {\n        console.error('Error fetching all workflows:', error);\n        return of([]);\n      }));\n    }\n    getById(id) {\n      // Check cache first\n      const cachedWorkflow = this.workflowCache.get(id);\n      if (cachedWorkflow) {\n        return of(cachedWorkflow);\n      }\n      return this.http.get(`${baseUrl}/${id}`).pipe(tap(workflow => {\n        console.log('Fetched workflow by ID:', workflow);\n        // Update cache\n        if (workflow) {\n          this.workflowCache.set(id, workflow);\n        }\n      }), catchError(error => {\n        console.error(`Error fetching workflow ID ${id}:`, error);\n        return throwError(() => error);\n      }));\n    }\n    update(id, params) {\n      console.log('Updating workflow with params:', params);\n      return this.http.put(`${baseUrl}/${id}`, params).pipe(tap(workflow => {\n        console.log('Workflow updated successfully:', workflow);\n        // Update cache\n        const cachedWorkflow = this.workflowCache.get(id);\n        if (cachedWorkflow) {\n          this.workflowCache.set(id, {\n            ...cachedWorkflow,\n            ...workflow\n          });\n        } else {\n          this.workflowCache.set(id, workflow);\n        }\n      }), catchError(error => {\n        console.error('Error updating workflow:', error);\n        return throwError(() => error);\n      }));\n    }\n    delete(id) {\n      return this.http.delete(`${baseUrl}/${id}`).pipe(tap(() => {\n        console.log(`Workflow ${id} deleted successfully`);\n        // Remove from cache\n        this.workflowCache.delete(id);\n      }), catchError(error => {\n        console.error(`Error deleting workflow ${id}:`, error);\n        return throwError(() => error);\n      }));\n    }\n    // Keep these methods for backward compatibility\n    getByEmployee(employeeId) {\n      return this.getByEmployeeId(Number(employeeId));\n    }\n    // Methods for workflow actions\n    approve(id, comment = '') {\n      return this.http.post(`${baseUrl}/${id}/approve`, {\n        comment\n      });\n    }\n    reject(id, comment = '') {\n      return this.http.post(`${baseUrl}/${id}/reject`, {\n        comment\n      });\n    }\n    static {\n      this.ɵfac = function WorkflowService_Factory(t) {\n        return new (t || WorkflowService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: WorkflowService,\n        factory: WorkflowService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return WorkflowService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}