{"ast":null,"code":"import { HttpErrorResponse } from '@angular/common/http';\nimport { throwError, of } from 'rxjs'; // Make sure 'of' is imported here\nimport { tap, catchError } from 'rxjs/operators';\nimport { environment } from '@environments/environment';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nconst baseUrl = `${environment.apiUrl}/requests`;\nexport let RequestService = /*#__PURE__*/(() => {\n  class RequestService {\n    constructor(http) {\n      this.http = http;\n      // Add cache for requests to improve loading speed\n      this.requestsCache = [];\n      this.requestByIdCache = new Map();\n    }\n    getAll() {\n      // Return cached data if available\n      if (this.requestsCache.length > 0) {\n        console.log('Using cached requests data');\n        // Return cache but refresh in background for next time\n        this.refreshCache();\n        return of(this.requestsCache);\n      }\n      return this.http.get(baseUrl).pipe(tap(requests => {\n        console.log('Fetched requests data:', requests);\n        // Normalize request data structure\n        const processedRequests = requests.map(request => {\n          const normalizedRequest = {\n            ...request\n          };\n          // Handle API inconsistency - it might return requestItems or RequestItems \n          if (normalizedRequest['RequestItems'] && !normalizedRequest.requestItems) {\n            normalizedRequest.requestItems = normalizedRequest['RequestItems'];\n          } else if (!normalizedRequest.requestItems) {\n            normalizedRequest.requestItems = [];\n          }\n          return normalizedRequest;\n        });\n        this.requestsCache = processedRequests;\n        // Cache individual requests by ID\n        processedRequests.forEach(request => {\n          if (request.id) {\n            this.requestByIdCache.set(request.id.toString(), request);\n          }\n        });\n      }), catchError(error => {\n        console.error('Error getting all requests:', error);\n        return throwError(() => this.extractErrorMessage(error));\n      }));\n    }\n    // Add a method to refresh the cache in the background\n    refreshCache() {\n      this.http.get(baseUrl).pipe(tap(requests => {\n        console.log('Background refreshed requests data');\n        // Process requests as before\n        const processedRequests = requests.map(request => {\n          const normalizedRequest = {\n            ...request\n          };\n          if (normalizedRequest['RequestItems'] && !normalizedRequest.requestItems) {\n            normalizedRequest.requestItems = normalizedRequest['RequestItems'];\n          } else if (!normalizedRequest.requestItems) {\n            normalizedRequest.requestItems = [];\n          }\n          return normalizedRequest;\n        });\n        this.requestsCache = processedRequests;\n        // Update cache\n        processedRequests.forEach(request => {\n          if (request.id) {\n            this.requestByIdCache.set(request.id.toString(), request);\n          }\n        });\n      }), catchError(error => {\n        console.error('Error refreshing requests cache:', error);\n        return of(null);\n      })).subscribe();\n    }\n    getById(id) {\n      const idStr = id.toString();\n      console.log(`Getting request with ID: ${idStr}`);\n      // Check if we have this request in our by-ID cache\n      const cachedRequest = this.requestByIdCache.get(idStr);\n      if (cachedRequest) {\n        console.log(`Using cached request for ID ${idStr}`, cachedRequest);\n        return of(cachedRequest);\n      }\n      // Not in cache, fetch from API\n      return this.http.get(`${baseUrl}/${id}`).pipe(tap(request => {\n        console.log('Retrieved request data from API:', request);\n        // Better request item handling\n        if (request) {\n          // Ensure requestItems is properly set\n          if (request['RequestItems'] && !request.requestItems) {\n            request.requestItems = request['RequestItems'];\n            console.log('Normalized RequestItems to requestItems:', request.requestItems);\n          } else if (!request.requestItems) {\n            request.requestItems = [];\n            console.log('Initialized empty requestItems array');\n          }\n        }\n        this.requestByIdCache.set(idStr, request);\n      }), catchError(error => {\n        console.error(`Error retrieving request with ID ${id}:`, error);\n        return throwError(() => this.extractErrorMessage(error));\n      }));\n    }\n    // Retry getting a request by ID if it fails\n    getByIdWithRetry(id, maxRetries = 2) {\n      return this.getById(id).pipe(catchError(error => {\n        // If we have this request in our cache, use that\n        const cachedRequest = this.requestByIdCache.get(id);\n        if (cachedRequest) {\n          console.log(`Using cached request for ID ${id} after API error`);\n          return of(cachedRequest);\n        }\n        if (maxRetries > 0) {\n          console.log(`Retrying getById for request ${id}, ${maxRetries} retries left`);\n          return this.getByIdWithRetry(id, maxRetries - 1);\n        }\n        return throwError(() => error);\n      }));\n    }\n    create(request) {\n      console.log('Creating new request:', request);\n      return this.http.post(baseUrl, request).pipe(tap(createdRequest => {\n        console.log('Successfully created request:', createdRequest);\n        // Update cache with the server response\n        if (createdRequest && createdRequest.id) {\n          this.requestByIdCache.set(createdRequest.id.toString(), createdRequest);\n          // Clear the full requests cache to force a refresh\n          this.requestsCache = [];\n        }\n      }), catchError(error => {\n        console.error('Error creating request:', error);\n        return throwError(() => this.extractErrorMessage(error));\n      }));\n    }\n    update(id, params) {\n      console.log(`Updating request ${id} with:`, params);\n      return this.http.put(`${baseUrl}/${id}`, params).pipe(tap(updatedRequest => {\n        console.log('Successfully updated request:', updatedRequest);\n        // Update cache with the server response\n        if (updatedRequest) {\n          this.requestByIdCache.set(id, updatedRequest);\n          // Clear the full requests cache to force a refresh\n          this.requestsCache = [];\n        }\n      }), catchError(error => {\n        console.error(`Error updating request ${id}:`, error);\n        return throwError(() => this.extractErrorMessage(error));\n      }));\n    }\n    delete(id) {\n      console.log(`Deleting request ${id}`);\n      // Remove from caches\n      this.requestByIdCache.delete(id);\n      // Clear the full requests cache to force a refresh\n      this.requestsCache = [];\n      return this.http.delete(`${baseUrl}/${id}`).pipe(tap(() => console.log(`Successfully deleted request ${id}`)), catchError(error => {\n        console.error(`Error deleting request ${id}:`, error);\n        return throwError(() => this.extractErrorMessage(error));\n      }));\n    }\n    getByEmployee(employeeId) {\n      console.log(`Getting requests for employee ${employeeId}`);\n      return this.http.get(`${baseUrl}/employee/${employeeId}`).pipe(tap(requests => console.log(`Found ${requests.length} requests for employee ${employeeId}`)), catchError(error => {\n        console.error(`Error getting requests for employee ${employeeId}:`, error);\n        return throwError(() => this.extractErrorMessage(error));\n      }));\n    }\n    extractErrorMessage(error) {\n      if (error instanceof HttpErrorResponse) {\n        if (error.error?.message) {\n          return error.error.message;\n        } else if (error.status === 0) {\n          return 'Unable to connect to server. Please try again later.';\n        } else {\n          return `Error ${error.status}: ${error.statusText || 'Unknown error'}`;\n        }\n      }\n      return error?.message || 'An unknown error occurred';\n    }\n    static {\n      this.ɵfac = function RequestService_Factory(t) {\n        return new (t || RequestService)(i0.ɵɵinject(i1.HttpClient));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: RequestService,\n        factory: RequestService.ɵfac,\n        providedIn: 'root'\n      });\n    }\n  }\n  return RequestService;\n})();","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}