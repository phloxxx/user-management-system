{"ast":null,"code":"import { HttpResponse, HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { of, throwError } from 'rxjs';\nimport { delay, materialize, dematerialize } from 'rxjs/operators';\nimport { Role } from '@app/_models';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@app/_services\";\n// array in local storage for accounts\nconst accountsKey = 'angular-10-signup-verification-boilerplate-accounts';\n// Get accounts from local storage\nlet accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n// Make sure all accounts have the required fields\naccounts = accounts.map(account => {\n  // Default to active if not specified\n  if (account.isActive === undefined) {\n    account.isActive = true;\n  }\n  // Ensure admin accounts are always active\n  if (account.role === Role.Admin) {\n    account.isActive = true;\n  }\n  // Ensure refreshTokens array exists\n  if (!account.refreshTokens) {\n    account.refreshTokens = [];\n  }\n  return account;\n});\n// Save the updated accounts back to localStorage\nlocalStorage.setItem(accountsKey, JSON.stringify(accounts));\nexport let FakeBackendInterceptor = /*#__PURE__*/(() => {\n  class FakeBackendInterceptor {\n    constructor(alertService) {\n      this.alertService = alertService;\n      this.users = [{\n        id: 1,\n        email: 'admin@example.com',\n        password: 'admin',\n        role: Role.Admin,\n        employeeId: 1\n      }, {\n        id: 2,\n        email: 'user@example.com',\n        password: 'user',\n        role: Role.User,\n        employeeId: 2\n      }];\n      this.employees = [{\n        id: 1,\n        employeeId: 'EMP001',\n        userId: 1,\n        position: 'Developer',\n        departmentId: 1,\n        hireDate: '2025-01-01',\n        status: 'Active'\n      }, {\n        id: 2,\n        employeeId: 'EMP002',\n        userId: 2,\n        position: 'Designer',\n        departmentId: 2,\n        hireDate: '2025-02-01',\n        status: 'Active'\n      }];\n      this.departments = [{\n        id: 1,\n        name: 'Engineering',\n        description: 'Software development team',\n        employeeCount: 1\n      }, {\n        id: 2,\n        name: 'Marketing',\n        description: 'Marketing team',\n        employeeCount: 1\n      }];\n      this.workflows = [{\n        id: 1,\n        employeeId: 1,\n        type: 'Onboarding',\n        details: {\n          task: 'Setup workstation'\n        },\n        status: 'Pending'\n      }];\n      this.requests = [{\n        id: 1,\n        employeeId: 2,\n        type: 'Equipment',\n        requestItems: [{\n          name: 'Laptop',\n          quantity: 1\n        }],\n        status: 'Pending'\n      }];\n      // Make sure our accounts and users are synchronized on startup\n      this.ensureDefaultAdminAccount();\n      this.syncUsersWithAccounts();\n      console.log('FakeBackendInterceptor initialized with users:', this.users);\n    }\n    // Make sure we have a default admin account in localStorage\n    ensureDefaultAdminAccount() {\n      try {\n        console.log('Ensuring default admin account exists...');\n        const storedAccounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n        const adminAccount = storedAccounts.find(a => a.role === Role.Admin);\n        if (!adminAccount) {\n          console.log('No admin account found in localStorage, creating one...');\n          const newAdminAccount = {\n            id: 1,\n            title: 'Mr',\n            firstName: 'Admin',\n            lastName: 'User',\n            email: 'admin@example.com',\n            password: 'admin',\n            role: Role.Admin,\n            isVerified: true,\n            isActive: true,\n            dateCreated: new Date().toISOString(),\n            refreshTokens: []\n          };\n          storedAccounts.push(newAdminAccount);\n          localStorage.setItem(accountsKey, JSON.stringify(storedAccounts));\n          console.log('Created admin account:', newAdminAccount);\n          // Update our global accounts variable\n          accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n        }\n      } catch (error) {\n        console.error('Error ensuring default admin account:', error);\n      }\n    }\n    // Helper method to synchronize localStorage accounts with hardcoded users array\n    syncUsersWithAccounts() {\n      try {\n        console.log('Synchronizing localStorage accounts with users array...');\n        // Get accounts from localStorage\n        const storedAccounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n        console.log('Stored accounts:', storedAccounts.map(a => ({\n          id: a.id,\n          email: a.email,\n          role: a.role\n        })));\n        // First, make sure our hardcoded users match what's in the accounts\n        storedAccounts.forEach(account => {\n          let matchingUser = this.users.find(u => u.email === account.email);\n          if (matchingUser) {\n            // Update the hardcoded user to match the account (especially the role)\n            console.log(`Syncing user ${matchingUser.email} with role ${account.role}`);\n            matchingUser.role = account.role;\n            matchingUser.id = account.id; // Ensure IDs match\n          } else {\n            // Create a new user if it doesn't exist in the hardcoded users\n            console.log(`User not found for account ${account.email}, creating...`);\n            this.users.push({\n              id: account.id,\n              email: account.email,\n              password: account.password || 'password',\n              role: account.role,\n              employeeId: account.id\n            });\n          }\n        });\n        // Now, make sure all hardcoded users exist in accounts\n        this.users.forEach(user => {\n          const matchingAccount = storedAccounts.find(a => a.email === user.email);\n          if (!matchingAccount) {\n            // Create an account for this hardcoded user\n            console.log(`Account not found for user ${user.email}, creating...`);\n            const newAccount = {\n              id: user.id,\n              title: 'Mr',\n              firstName: user.email.split('@')[0],\n              lastName: 'User',\n              email: user.email,\n              password: user.password,\n              role: user.role,\n              isVerified: true,\n              isActive: true,\n              dateCreated: new Date().toISOString(),\n              refreshTokens: []\n            };\n            storedAccounts.push(newAccount);\n          }\n        });\n        // Save any changes back to localStorage\n        localStorage.setItem(accountsKey, JSON.stringify(storedAccounts));\n        // Update the global accounts variable\n        accounts = JSON.parse(localStorage.getItem(accountsKey)) || [];\n        console.log('Synchronization complete:');\n        console.log('- Updated users:', this.users);\n        console.log('- Updated accounts:', accounts.map(a => ({\n          id: a.id,\n          email: a.email,\n          role: a.role\n        })));\n      } catch (error) {\n        console.error('Error synchronizing users with accounts:', error);\n      }\n    }\n    intercept(request, next) {\n      const {\n        url,\n        method,\n        headers,\n        body\n      } = request;\n      const alertService = this.alertService;\n      // Store a reference to 'this' to access class properties inside closures\n      const self = this;\n      return handleRoute();\n      function handleRoute() {\n        // Handle authentication and account-related routes\n        switch (true) {\n          case url.endsWith('/accounts/authenticate') && method === 'POST':\n            return authenticate();\n          case url.endsWith('/accounts/refresh-token') && method === 'POST':\n            return refreshToken();\n          case url.endsWith('/accounts/revoke-token') && method === 'POST':\n            return revokeToken();\n          case url.endsWith('/accounts/register') && method === 'POST':\n            return register();\n          case url.endsWith('/accounts/verify-email') && method === 'POST':\n            return verifyEmail();\n          case url.endsWith('/accounts/forgot-password') && method === 'POST':\n            return forgotPassword();\n          case url.endsWith('/accounts/validate-reset-token') && method === 'POST':\n            return validateResetToken();\n          case url.endsWith('/accounts/reset-password') && method === 'POST':\n            return resetPassword();\n          case url.endsWith('/accounts') && method === 'GET':\n            return getAccounts();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'GET':\n            return getAccountById();\n          case url.endsWith('/accounts') && method === 'POST':\n            return createAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'PUT':\n            return updateAccount();\n          case url.match(/\\/accounts\\/\\d+$/) && method === 'DELETE':\n            return deleteAccount();\n          case url.match(/\\/accounts\\/\\d+\\/status$/) && method === 'PUT':\n            return updateAccountStatus();\n          // HR System routes    \n          case url.endsWith('/employees') && method === 'GET':\n            return getEmployees();\n          case url.endsWith('/employees') && method === 'POST':\n            return createEmployee();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'GET':\n            return getEmployeeById();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'PUT':\n            return updateEmployee();\n          case url.match(/\\/employees\\/\\d+$/) && method === 'DELETE':\n            return deleteEmployee();\n          case url.match(/\\/employees\\/\\d+\\/transfer$/) && method === 'POST':\n            return transferEmployee();\n          case url.endsWith('/departments') && method === 'GET':\n            return getDepartments();\n          case url.endsWith('/departments') && method === 'POST':\n            return createDepartment();\n          case url.match(/\\/departments\\/\\d+$/) && method === 'PUT':\n            return updateDepartment();\n          case url.match(/\\/departments\\/\\d+$/) && method === 'DELETE':\n            return deleteDepartment();\n          case url.match(/\\/workflows\\/employee\\/\\d+$/) && method === 'GET':\n            return getEmployeeWorkflows();\n          case url.endsWith('/workflows') && method === 'POST':\n            return createWorkflow();\n          case url.endsWith('/requests') && method === 'GET':\n            return getRequests();\n          case url.endsWith('/requests') && method === 'POST':\n            return createRequest();\n          case url.match(/\\/requests\\/\\d+$/) && method === 'PUT':\n            return updateRequest();\n          case url.match(/\\/requests\\/\\d+$/) && method === 'DELETE':\n            return deleteRequest();\n          default:\n            // pass through any requests not handled above\n            return next.handle(request);\n        }\n      }\n      // HR System route functions\n      function getEmployees() {\n        return authorize(null, () => {\n          // Additional logging to debug authorization issues\n          console.log('Fake backend: Authorized user accessing employees data');\n          return ok(self.employees);\n        });\n      }\n      function createEmployee() {\n        return authorize(Role.Admin, () => {\n          const employee = {\n            id: self.employees.length + 1,\n            ...body\n          };\n          // Make sure the employee has a userId (account) and departmentId\n          if (!employee.userId) {\n            console.warn('Employee created without userId! Setting to default value');\n            employee.userId = 1; // Default to admin\n          }\n          if (!employee.departmentId) {\n            console.warn('Employee created without departmentId! Setting to default value');\n            employee.departmentId = 1; // Default to first department\n          }\n          console.log('Creating employee:', employee);\n          self.employees.push(employee);\n          // Automatically create an onboarding workflow for the new employee\n          const onboardingWorkflow = {\n            id: self.workflows.length + 1,\n            employeeId: employee.id,\n            type: 'Onboarding',\n            details: {\n              task: 'Complete HR Forms (Step 1)'\n            },\n            status: 'Pending',\n            createdDate: new Date().toISOString(),\n            updatedDate: new Date().toISOString()\n          };\n          self.workflows.push(onboardingWorkflow);\n          console.log(`Created onboarding workflow for new employee:`, onboardingWorkflow);\n          return ok(employee);\n        });\n      }\n      function getEmployeeById() {\n        return authorize(null, () => {\n          const id = parseInt(url.split('/').pop());\n          const employee = self.employees.find(e => e.id === id);\n          return employee ? ok(employee) : error('Employee not found');\n        });\n      }\n      function updateEmployee() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/').pop());\n          const employeeIndex = self.employees.findIndex(e => e.id === id);\n          if (employeeIndex === -1) return error('Employee not found');\n          self.employees[employeeIndex] = {\n            id,\n            ...body\n          };\n          return ok(self.employees[employeeIndex]);\n        });\n      }\n      function deleteEmployee() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/').pop());\n          self.employees = self.employees.filter(e => e.id !== id);\n          return ok({\n            message: 'Employee deleted'\n          });\n        });\n      }\n      function transferEmployee() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/')[2]);\n          const employee = self.employees.find(e => e.id === id);\n          if (!employee) return error('Employee not found');\n          employee.departmentId = body.departmentId;\n          self.workflows.push({\n            id: self.workflows.length + 1,\n            employeeId: id,\n            type: 'Transfer',\n            details: body,\n            status: 'Pending'\n          });\n          return ok({\n            message: 'Employee transferred'\n          });\n        });\n      }\n      function getDepartments() {\n        return authorize(null, () => ok(self.departments));\n      }\n      function createDepartment() {\n        console.log('=======================================================');\n        console.log('CREATE DEPARTMENT DEBUG - START');\n        console.log('=======================================================');\n        console.log('Create department called with body:', body);\n        logAuthStatus('POST /departments');\n        // Log the token parsing details\n        const authHeader = headers.get('Authorization');\n        if (authHeader && authHeader.startsWith('Bearer ')) {\n          const token = authHeader.substring(7);\n          console.log('Token being used for department creation:', token.substring(0, 20) + '...');\n          try {\n            if (token.startsWith('fake-jwt-token.')) {\n              const payload = token.split('.')[1];\n              const decodedPayload = JSON.parse(atob(payload));\n              console.log('Decoded token payload:', decodedPayload);\n              // Check token expiration\n              const tokenExpires = new Date(decodedPayload.exp * 1000);\n              const now = new Date();\n              console.log('Token expires at:', tokenExpires.toISOString());\n              console.log('Current time:', now.toISOString());\n              console.log('Token expired:', tokenExpires < now);\n              // Log account information\n              const account = accounts.find(x => x.id === decodedPayload.id);\n              if (account) {\n                console.log('Account found from token:', {\n                  id: account.id,\n                  email: account.email,\n                  role: account.role,\n                  isActive: account.isActive\n                });\n                // Find matching user in self.users array\n                console.log('Available users:', self.users);\n                const user = self.users.find(u => u.email === account.email);\n                if (user) {\n                  console.log('User found from account:', user);\n                  console.log('User has Admin role:', user.role === Role.Admin);\n                } else {\n                  console.log('⚠️ ERROR: No matching user found in users array for account email:', account.email);\n                  console.log('This may be why authorization is failing!');\n                  // Fix: Add the user on-the-fly if missing\n                  self.users.push({\n                    id: account.id,\n                    email: account.email,\n                    password: 'password',\n                    // Default password\n                    role: account.role,\n                    employeeId: account.id\n                  });\n                  console.log('🔧 Created missing user for account:', account.email);\n                }\n              } else {\n                console.log('⚠️ ERROR: No account found for token ID:', decodedPayload.id);\n                console.log('Available accounts:', accounts.map(a => ({\n                  id: a.id,\n                  email: a.email,\n                  role: a.role\n                })));\n              }\n            } else {\n              console.log('⚠️ ERROR: Token does not start with \"fake-jwt-token.\"');\n            }\n          } catch (e) {\n            console.error('⚠️ ERROR: Error processing token:', e);\n          }\n        } else {\n          console.log('⚠️ ERROR: Invalid Authorization header format');\n        }\n        console.log('Trying to authorize with Admin role...');\n        return authorize(Role.Admin, () => {\n          console.log('✅ Authorization successful! Creating department...');\n          const department = {\n            id: self.departments.length + 1,\n            ...body,\n            employeeCount: 0\n          };\n          self.departments.push(department);\n          console.log('Department created successfully:', department);\n          console.log('=======================================================');\n          console.log('CREATE DEPARTMENT DEBUG - END');\n          console.log('=======================================================');\n          return ok(department);\n        });\n      }\n      function updateDepartment() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/').pop());\n          const deptIndex = self.departments.findIndex(d => d.id === id);\n          if (deptIndex === -1) return error('Department not found');\n          self.departments[deptIndex] = {\n            id,\n            ...body,\n            employeeCount: self.departments[deptIndex].employeeCount\n          };\n          return ok(self.departments[deptIndex]);\n        });\n      }\n      function deleteDepartment() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/').pop());\n          self.departments = self.departments.filter(d => d.id !== id);\n          return ok({\n            message: 'Department deleted'\n          });\n        });\n      }\n      function getEmployeeWorkflows() {\n        return authorize(null, () => {\n          const employeeId = parseInt(url.split('/').pop());\n          console.log(`Fake backend: Getting workflows for employee ID ${employeeId}`);\n          let workflows = self.workflows.filter(w => w.employeeId === employeeId);\n          // Enhance workflows with additional properties\n          workflows = workflows.map(workflow => ({\n            ...workflow,\n            createdDate: new Date().toISOString(),\n            updatedDate: new Date().toISOString(),\n            type: workflow.type || 'Unknown',\n            status: workflow.status || 'Pending'\n          }));\n          console.log(`Fake backend: Found ${workflows.length} workflows:`, workflows);\n          return ok(workflows);\n        });\n      }\n      function createWorkflow() {\n        return authorize(Role.Admin, () => {\n          const workflow = {\n            id: self.workflows.length + 1,\n            ...body\n          };\n          self.workflows.push(workflow);\n          return ok(workflow);\n        });\n      }\n      function getRequests() {\n        // Allow both admin and regular users to see requests\n        return authorize(null, () => {\n          const user = getUser();\n          // If admin, return all requests\n          if (user.role === Role.Admin) {\n            return ok(self.requests);\n          }\n          // If regular user, return only their requests\n          const userRequests = self.requests.filter(r => r.employeeId === user.employeeId);\n          console.log(`Filtered requests for user ${user.email}:`, userRequests);\n          return ok(userRequests);\n        });\n      }\n      function createRequest() {\n        return authorize(null, () => {\n          const user = getUser();\n          // Get the actual employee record for this user\n          let employeeId = user.employeeId;\n          // If no employee record exists for this user, create one\n          if (!self.employees.find(e => e.id === employeeId)) {\n            const newEmployee = {\n              id: self.employees.length + 1,\n              employeeId: `EMP${(self.employees.length + 1).toString().padStart(3, '0')}`,\n              userId: user.id,\n              position: 'Staff',\n              departmentId: 1,\n              hireDate: new Date().toISOString().split('T')[0],\n              status: 'Active'\n            };\n            self.employees.push(newEmployee);\n            employeeId = newEmployee.id;\n            console.log(`Created new employee record for user ${user.email}:`, newEmployee);\n          }\n          const request = {\n            id: self.requests.length + 1,\n            employeeId: employeeId,\n            // Use the actual employee ID\n            status: body.status || 'Pending',\n            createdDate: new Date().toISOString(),\n            ...body\n          };\n          // Ensure requestItems is an array\n          if (!request.requestItems) {\n            request.requestItems = [];\n          }\n          console.log('Request created:', request);\n          console.log('Employee ID used:', employeeId);\n          console.log('Available employees:', self.employees);\n          console.log('Available users:', self.users);\n          console.log('Available accounts:', accounts);\n          self.requests.push(request);\n          return ok(request);\n        });\n      }\n      function updateRequest() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/').pop());\n          const reqIndex = self.requests.findIndex(r => r.id === id);\n          if (reqIndex === -1) return error('Request not found');\n          self.requests[reqIndex] = {\n            id,\n            ...body\n          };\n          return ok(self.requests[reqIndex]);\n        });\n      }\n      function deleteRequest() {\n        return authorize(Role.Admin, () => {\n          const id = parseInt(url.split('/').pop());\n          self.requests = self.requests.filter(r => r.id !== id);\n          return ok({\n            message: 'Request deleted'\n          });\n        });\n      }\n      // Account route functions\n      function authenticate() {\n        const {\n          email,\n          password\n        } = body;\n        console.log(`Authentication attempt for email: ${email}`);\n        // First, find the account by email and password\n        const account = accounts.find(x => x.email === email && x.password === password);\n        // Check if account exists and is verified\n        if (!account || !account.isVerified) {\n          console.log(`Authentication failed: Account not found or not verified for email: ${email}`);\n          return error('Email or password is incorrect');\n        }\n        // Check if the account is active for non-admin users\n        if (account.role !== Role.Admin && account.isActive === false) {\n          console.log(`Authentication failed: Account is deactivated for email: ${email}`);\n          return error('Your account has been deactivated. Please contact an administrator.');\n        }\n        // Authentication successful - proceed with token generation\n        console.log(`Authentication successful for: ${email}, role: ${account.role}`);\n        account.refreshTokens = account.refreshTokens || [];\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        const token = generateJwtToken(account);\n        console.log(`Generated token for ${email}: ${token}`);\n        // After successful authentication, make sure users are in sync\n        self.syncUsersWithAccounts();\n        return ok({\n          ...basicDetails(account),\n          jwtToken: token\n        });\n      }\n      function refreshToken() {\n        const refreshToken = getRefreshToken();\n        if (!refreshToken) return unauthorized();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        if (!account) return unauthorized();\n        // replace old refresh token with a new one and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        account.refreshTokens.push(generateRefreshToken());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok({\n          ...basicDetails(account),\n          jwtToken: generateJwtToken(account)\n        });\n      }\n      function revokeToken() {\n        if (!isAuthenticated()) return unauthorized();\n        const refreshToken = getRefreshToken();\n        const account = accounts.find(x => x.refreshTokens.includes(refreshToken));\n        // revoke token and save\n        account.refreshTokens = account.refreshTokens.filter(x => x !== refreshToken);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function register() {\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          // display email already registered \"email\" in alert\n          setTimeout(() => {\n            alertService.info(`\n                    <h4>Email Already Registered</h4>\n                    <p>Your email <strong>${account.email}</strong> is already registered.</p>\n                    <p>If you don't know your password please visit the <a href=\"${location.origin}/account/forgot-password\">forgot password</a> page.</p>\n                    <div><strong>Note:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                    `, {\n              autoClose: false\n            });\n          }, 1000);\n          // always return ok() response to prevent email enumeration\n          return ok();\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        if (account.id === 1) {\n          // first registered account is an admin\n          account.role = Role.Admin;\n        } else {\n          account.role = Role.User;\n        }\n        account.dateCreated = new Date().toISOString();\n        account.verificationToken = new Date().getTime().toString();\n        account.isVerified = false;\n        account.isActive = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // Update our users array to stay in sync\n        self.syncUsersWithAccounts();\n        // display verification email in alert\n        setTimeout(() => {\n          const verifyUrl = `${location.origin}/account/verify-email?token=${account.verificationToken}`;\n          alertService.info(`\n                <h4>Verification Email</h4>\n                <p>Thanks for registering!</p>\n                <p>Please click the below link to verify your email address:</p>\n                <p><a href=\"${verifyUrl}\">${verifyUrl}</a></p>\n                <div><strong>Note:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function verifyEmail() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => !!x.verificationToken && x.verificationToken === token);\n        if (!account) return error('Verification failed');\n        // set is verified flag to true if token is valid\n        account.isVerified = true;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function forgotPassword() {\n        const {\n          email\n        } = body;\n        const account = accounts.find(x => x.email === email);\n        // always return ok() response to prevent email enumeration\n        if (!account) return ok();\n        // create reset token that expires after 24 hours\n        account.resetToken = new Date().getTime().toString();\n        account.resetTokenExpires = new Date(Date.now() + 24 * 60 * 60 * 1000).toISOString();\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // display password reset email in alert\n        setTimeout(() => {\n          const resetUrl = `${location.origin}/account/reset-password?token=${account.resetToken}`;\n          alertService.info(`\n                <h4>Reset Password Email</h4>\n                <p>Please click the below link to reset your password, the link will be valid for 1 day:</p>\n                <p><a href=\"${resetUrl}\">${resetUrl}</a></p>\n                <div><strong>Note:</strong> The fake backend displayed this \"email\" so you can test without an api. A real backend would send a real email.</div>\n                `, {\n            autoClose: false\n          });\n        }, 1000);\n        return ok();\n      }\n      function validateResetToken() {\n        const {\n          token\n        } = body;\n        const account = accounts.find(x => x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        return ok();\n      }\n      function resetPassword() {\n        const {\n          token,\n          password\n        } = body;\n        const account = accounts.find(x => !!x.resetToken && x.resetToken === token && new Date() < new Date(x.resetTokenExpires));\n        if (!account) return error('Invalid token');\n        // update password and remove reset token\n        account.password = password;\n        account.isVerified = true;\n        delete account.resetToken;\n        delete account.resetTokenExpires;\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        return ok();\n      }\n      function getAccounts() {\n        if (!isAuthenticated()) return unauthorized();\n        return ok(accounts.map(x => basicDetails(x)));\n      }\n      function getAccountById() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can get own profile and admin accounts can get all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        return ok(basicDetails(account));\n      }\n      function createAccount() {\n        if (!isAuthorized(Role.Admin)) return unauthorized();\n        if (body.isActive === undefined) {\n          body.isActive = true;\n        }\n        if (body.role === Role.Admin) {\n          body.isActive = true;\n        }\n        const account = body;\n        if (accounts.find(x => x.email === account.email)) {\n          return error(`Email ${account.email} is already registered`);\n        }\n        // assign account id and a few other properties then save\n        account.id = newAccountId();\n        account.dateCreated = new Date().toISOString();\n        account.isVerified = true;\n        account.refreshTokens = [];\n        delete account.confirmPassword;\n        accounts.push(account);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // Update our users array to stay in sync\n        self.syncUsersWithAccounts();\n        return ok();\n      }\n      function updateAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let params = body;\n        let account = accounts.find(x => x.id === idFromUrl()); // user accounts can update own profile and admin accounts can update all profiles\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // only update password if included\n        if (!params.password) {\n          delete params.password;\n        }\n        // don't save confirm password\n        delete params.confirmPassword;\n        // update and save account\n        Object.assign(account, params);\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // Update our users array to stay in sync\n        self.syncUsersWithAccounts();\n        return ok(basicDetails(account));\n      }\n      function deleteAccount() {\n        if (!isAuthenticated()) return unauthorized();\n        let account = accounts.find(x => x.id === idFromUrl());\n        // user accounts can delete own account and admin accounts can delete any account\n        if (account.id !== currentAccount().id && !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // delete account then save\n        accounts = accounts.filter(x => x.id !== idFromUrl());\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // Update our users array to stay in sync\n        self.syncUsersWithAccounts();\n        return ok();\n      }\n      function updateAccountStatus() {\n        if (!isAuthenticated() || !isAuthorized(Role.Admin)) {\n          return unauthorized();\n        }\n        // Extract the account ID from the URL (e.g., /accounts/123/status)\n        const urlParts = url.split('/');\n        const id = parseInt(urlParts[urlParts.length - 2]);\n        // Find the account by ID\n        const account = accounts.find(x => x.id === id);\n        // Check if account exists\n        if (!account) {\n          return notFound();\n        }\n        // Don't allow changing status of admin accounts\n        if (account.role === Role.Admin) {\n          return error('Cannot change status of admin accounts');\n        }\n        // Update the account status\n        account.isActive = !!body.isActive;\n        // Save the updated accounts to localStorage\n        localStorage.setItem(accountsKey, JSON.stringify(accounts));\n        // Update our users array to stay in sync\n        self.syncUsersWithAccounts();\n        // Return the updated account details\n        return ok({\n          ...basicDetails(account)\n        });\n      }\n      // helper functions\n      function ok(body) {\n        return of(new HttpResponse({\n          status: 200,\n          body\n        })).pipe(delay(500));\n      }\n      function error(message) {\n        return throwError({\n          error: {\n            message\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function unauthorized() {\n        return throwError({\n          status: 401,\n          error: {\n            message: 'Unauthorized'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function notFound() {\n        return throwError({\n          status: 404,\n          error: {\n            message: 'Not Found'\n          }\n        }).pipe(materialize(), delay(500), dematerialize());\n      }\n      function authorize(requiredRole, callback) {\n        console.log(`FAKE BACKEND - Authorize function called with requiredRole: ${requiredRole || 'none'}`);\n        console.log(`FAKE BACKEND - Current URL: ${url}, Method: ${method}`);\n        const user = getUser();\n        console.log(`FAKE BACKEND - User from getUser():`, user);\n        if (!user) {\n          console.error('FAKE BACKEND - Authorization failed: No user found from token');\n          return unauthorized();\n        }\n        if (requiredRole && user.role !== requiredRole) {\n          console.error(`FAKE BACKEND - Authorization failed: User role ${user.role} does not match required role ${requiredRole}`);\n          return error('Forbidden');\n        }\n        console.log(`FAKE BACKEND - User authorized: ${user.email}, role: ${user.role}`);\n        return callback();\n      }\n      function getUser() {\n        const authHeader = headers.get('Authorization');\n        console.log('FAKE BACKEND - Auth header:', authHeader ? `${authHeader.substring(0, 15)}...` : 'none');\n        if (!authHeader || !authHeader.startsWith('Bearer ')) {\n          console.log('FAKE BACKEND - Missing or invalid Authorization header');\n          return null;\n        }\n        // Extract the token\n        const token = authHeader.substring(7);\n        console.log('FAKE BACKEND - Token:', token.substring(0, 15) + '...');\n        try {\n          // First, check for our specific fake-jwt-token format\n          if (token.startsWith('fake-jwt-token.')) {\n            try {\n              // This matches our generateJwtToken function format\n              const payload = token.split('.')[1];\n              const decodedPayload = JSON.parse(atob(payload));\n              console.log('FAKE BACKEND - Decoded payload:', decodedPayload);\n              // Verify token hasn't expired\n              const tokenExpired = Date.now() > decodedPayload.exp * 1000;\n              console.log('FAKE BACKEND - Token expired:', tokenExpired);\n              if (tokenExpired) {\n                console.log('Token expired');\n                return null;\n              }\n              // Get account from token\n              console.log('FAKE BACKEND - Looking for account with ID:', decodedPayload.id);\n              console.log('FAKE BACKEND - Available accounts:', accounts.map(a => ({\n                id: a.id,\n                email: a.email,\n                role: a.role\n              })));\n              const account = accounts.find(x => x.id === decodedPayload.id);\n              if (account) {\n                console.log('FAKE BACKEND - Found account:', {\n                  id: account.id,\n                  email: account.email,\n                  role: account.role\n                });\n                // Find and return matching user\n                console.log('FAKE BACKEND - Available users:', self.users);\n                const user = self.users.find(u => u.email === account.email);\n                if (user) {\n                  console.log(`FAKE BACKEND - Found user by token: ${user.email}, role: ${user.role}`);\n                  return user;\n                } else {\n                  console.log(`FAKE BACKEND - No matching user found for account email: ${account.email}`);\n                  // Create a user on-the-fly\n                  const newUser = {\n                    id: account.id,\n                    email: account.email,\n                    password: account.password || 'password',\n                    role: account.role,\n                    employeeId: account.id\n                  };\n                  self.users.push(newUser);\n                  console.log(`FAKE BACKEND - Created missing user: ${newUser.email}, role: ${newUser.role}`);\n                  return newUser;\n                }\n              } else {\n                console.log(`FAKE BACKEND - No account found for ID: ${decodedPayload.id}`);\n              }\n            } catch (e) {\n              console.error('FAKE BACKEND - Error decoding JWT payload:', e);\n            }\n          } else {\n            console.log('FAKE BACKEND - Not a fake-jwt-token format');\n          }\n          // Fallback: For any token that looks like JWT but doesn't match our format\n          if (token && token.split('.').length === 3) {\n            console.log('FAKE BACKEND - Using fallback authentication for non-standard JWT');\n            const adminUser = self.users.find(u => u.role === Role.Admin);\n            console.log('FAKE BACKEND - Fallback user:', adminUser || self.users[0]);\n            return adminUser || self.users[0];\n          }\n        } catch (error) {\n          console.error('FAKE BACKEND - Error processing token:', error);\n        }\n        console.log('FAKE BACKEND - No user found from token');\n        return null;\n      }\n      function basicDetails(account) {\n        const {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          isActive\n        } = account;\n        return {\n          id,\n          title,\n          firstName,\n          lastName,\n          email,\n          role,\n          dateCreated,\n          isVerified,\n          isActive\n        };\n      }\n      function isAuthenticated() {\n        return !!currentAccount();\n      }\n      function isAuthorized(role) {\n        const account = currentAccount();\n        if (!account) return false;\n        return account.role === role;\n      }\n      function idFromUrl() {\n        const urlParts = url.split('/');\n        return parseInt(urlParts[urlParts.length - 1]);\n      }\n      function newAccountId() {\n        return accounts.length ? Math.max(...accounts.map(x => x.id)) + 1 : 1;\n      }\n      function currentAccount() {\n        const authHeader = headers.get('Authorization');\n        if (!authHeader || !authHeader.startsWith('Bearer fake-jwt-token')) return;\n        try {\n          const jwtToken = JSON.parse(atob(authHeader.split('.')[1]));\n          const tokenExpired = Date.now() > jwtToken.exp * 1000;\n          if (tokenExpired) {\n            console.log('Token expired');\n            return;\n          }\n          const account = accounts.find(x => x.id === jwtToken.id);\n          return account;\n        } catch (error) {\n          console.error('Error parsing JWT token:', error);\n          return;\n        }\n      }\n      function generateJwtToken(account) {\n        const tokenPayload = {\n          exp: Math.round(new Date(Date.now() + 15 * 60 * 1000).getTime() / 1000),\n          id: account.id\n        };\n        return `fake-jwt-token.${btoa(JSON.stringify(tokenPayload))}`;\n      }\n      function generateRefreshToken() {\n        const token = new Date().getTime().toString();\n        const expires = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toUTCString();\n        document.cookie = `fakeRefreshToken=${token}; expires=${expires}; path=/`;\n        return token;\n      }\n      // Diagnostic helper function to check user and role\n      function logAuthStatus(endpoint) {\n        console.log(`\\n==========================================`);\n        console.log(`AUTH STATUS CHECK for endpoint: ${endpoint}`);\n        console.log(`------------------------------------------`);\n        const authHeader = headers.get('Authorization');\n        console.log(`Authorization header present: ${!!authHeader}`);\n        if (authHeader) {\n          console.log(`Header starts with Bearer: ${authHeader.startsWith('Bearer ')}`);\n          const token = authHeader.substring(7);\n          console.log(`Token preview: ${token.substring(0, 15)}...`);\n          try {\n            const parts = token.split('.');\n            if (parts.length === 3) {\n              const decoded = JSON.parse(atob(parts[1]));\n              console.log(`Token payload:`, decoded);\n              console.log(`Token expiration: ${new Date(decoded.exp * 1000).toISOString()}`);\n              console.log(`Token expired: ${new Date(decoded.exp * 1000) < new Date()}`);\n              const account = accounts.find(x => x.id === decoded.id);\n              console.log(`Account found: ${!!account}`);\n              if (account) {\n                console.log(`Account details: ID=${account.id}, Email=${account.email}, Role=${account.role}`);\n                console.log(`Is Admin: ${account.role === Role.Admin}`);\n              }\n            }\n          } catch (e) {\n            console.log(`Error decoding token: ${e.message}`);\n          }\n        }\n        console.log(`==========================================\\n`);\n      }\n      function getRefreshToken() {\n        return (document.cookie.split(';').find(x => x.includes('fakeRefreshToken')) || '=').split('=')[1];\n      }\n    }\n    static {\n      this.ɵfac = function FakeBackendInterceptor_Factory(t) {\n        return new (t || FakeBackendInterceptor)(i0.ɵɵinject(i1.AlertService));\n      };\n    }\n    static {\n      this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n        token: FakeBackendInterceptor,\n        factory: FakeBackendInterceptor.ɵfac\n      });\n    }\n  }\n  return FakeBackendInterceptor;\n})();\nexport const fakeBackendProvider = {\n  provide: HTTP_INTERCEPTORS,\n  useClass: FakeBackendInterceptor,\n  multi: true\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}